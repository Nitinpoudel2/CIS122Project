public void actionPerformed(java.awt.event.ActionEvent evt) // Provides interfaces and classes for dealing with different types of events fired by AWT components.
	{ //// Contains all of the classes for creating user interfaces and for painting graphics and images.
		for (int i = 0; i < 9; i++) // loop
		{
			for (int j = 0; j< 9; j++) // loop
			{
				int playoff = playoffNumber(i, j); // shows the msg according to the wins/ placements where player can play
				if ((button[i][j] == evt.getSource()) && (!isNear(i, j)))
				{
					if ((unavoidable) && (buttonPressed) && (next != playoff))
					{
						if (player1) {
							JOptionPane.showMessageDialog(this, "It's not your turn , " + Name1 + "!"); // Player is playing on wrong board 
						} else
							JOptionPane.showMessageDialog(this, "It is not your turn , AI"); // AI: you are not in the right board
						return;
					}
					if (!buttonPressed) // dialogs part
						buttonPressed = true;
					if (GameOver(playoff) >= 0) 
					{
						if (player1) // its on the players turns 
						{
							if (GameOver(playoff) == 0) // // makes it easy to pop up a standard dialog box that prompts users
							{
								JOptionPane.showMessageDialog(this, "This playoff is already won by the AI"); // this is where player can not play because its won by AI
							}
							else if (GameOver(playoff) == 1) // on player side
							{
								JOptionPane.showMessageDialog(this, "This playoff is already won by you, " + Name1 + "!"); // this is where player cant play because player has already won on this board
							}


						}
						else if (GameOver(playoff) == 0) // on side of the AI
						{
							JOptionPane.showMessageDialog(this, "This playoff is already won by you, AI!"); // this board the already won by AI. thats why player can not play on this
						}
						else if (GameOver(playoff) == 1) // on player side
						{
							JOptionPane.showMessageDialog(this, "This playoff is already won by " + Name1 + "!"); // this is where player cant play because player has already won on this board 
						}

						return;
					}
					if (player1) // it add colours to the background  of "X"
					{
						button[i][j].setForeground(java.awt.Color.RED); // player plays as red color 
						button[i][j].setText("X"); 
						h += 1;
						input(i, j, 1);
						player1 = false;
						turn.setText("AI's TURN !!"); // done with players ,now its AI's turn
						turn.setForeground(java.awt.Color.RED); // bot dialog box colour
					}
					else // setup the color
					{
						button[i][j].setForeground(java.awt.Color.BLUE); // AI plays in the Colour blue ie "O"
						button[i][j].setText("0");
						this.r += 1;
						input(i, j, 0);
						player1 = true; // now its players turn
						turn.setText(Name1 + "'s TURN !!");
						turn.setForeground(java.awt.Color.RED); // dialog box colour is red
					}
					alternate += 1; // turns and positions alterations
					int[] position = hpm(playoff); // player position
					int r = position[0];int c = position[1]; // // bot position
					if (GameOver(playoff) >= 0) /// add more dialogs // when the board is won by anyone it shows/ pop up this dialog boxes 
					{
						if (GameOver(playoff) == 0) // AI won on this board 
						{
							colorPlayOff(playoff, 0);
							mainInterface[r][c] = 0;
							JOptionPane.showMessageDialog(this, "AI Wins this playoff\nThis playoff will be counted as \"AI\"");
						}
						else if (GameOver(playoff) == 1)  // all the boxes are fill and the game is tied 
						{
							colorPlayOff(playoff, 1);
							mainInterface[r][c] = 1;
							JOptionPane.showMessageDialog(this, Name1 + " Wins this playoff\nThis playoff will be counted as \"" + Name1 + "'s\"");
						}
						if (!gameWork()) {}

					}
					else if (isB_Filled(playoff)) // shows the box is tied 
					{
						colorPlayOff(playoff, 2);
						mainInterface[r][c] = 2;
						JOptionPane.showMessageDialog(this, "This playoff is tied\nThis playoff will be counted for both players");
						if (gameWork())
							return;
						if (GameOver() >= 0) // final part
						{
							if (GameOver() == 0)  // AI wins the game
							{
								JOptionPane.showMessageDialog(this, "AI wins the game!");
								turn.setText("Bot wins!");
								setVisible(false); // it marks the component visible
							
							}
							else if (GameOver() == 1) // player wins the game
							{
								JOptionPane.showMessageDialog(this, Name1 + " wins the game!");
								turn.setText(Name1 + " wins!");
								setVisible(false);
							
							}
							disableAllplayoffs(true);
							return;
						}
						if (mainInterfaceFull()) // its that the game is tied
						{
							disableAllplayoffs(true);
							turn.setText("Game tied!");
							setVisible(false);
						
						}
					}
					int[] ops = positionInBoard(i, j); // tracks the placements on board 
					int hog  = byteMark(ops[0], ops[1]);
					if (!playoffisSolved(hog))
					{
						next = hog; // Java Scanner class which finds and returns the next complete token
						colorPlayOff(hog, 3);
						unavoidable = true; // forced to use raw types in its method signatures and return types because the methods it overrides from a super type
					}
					else
					{
						unavoidable = false; //// forced to use raw types in its method signatures and will not return types because the methods it overrides from a super type
						for (int g = 0; g <= 8; g++) {
							colorPlayOff(g, 5);
						}
					}
					if (!player1)
					{
						disableAllplayoffs(false);
						java.util.Timer timer = new java.util.Timer(); // threads to schedule tasks for future execution in a background thread
						Beginner.AIWork timer1 = new Beginner.AIWork();
						timer1.take(hog, i, j);
						int wait; // instance method that's used for thread synchronization
						 if (alternate <= 30) { // set up the timer
							wait = 500 + (int)(Math.random() * 1501.0D); } 
						 else { 
							if ( alternate <= 60) {
								wait = 2000 + (int)(Math.random() * 1501.0D);
							} else
								wait = 3000 + (int)(Math.random() * 2001.0D); }
						 timer.schedule(timer1, wait);
					}
					return; // timer end
				}
			}
		}
	}

	private boolean gameWork() // boolean values which returns only true or false
	{
		int result = GameOver(); // end of game
		if (GameOver() >= 0)
		{
			switch (result)// sees who wins and shows the dialogs box accordingly 
			{
			case 0: // shows when AI wins the game
				JOptionPane.showMessageDialog(this, "AI wins the game!");
				turn.setText("AI wins!");
				setVisible(false);
				
			case 1: // shows when player wins the game
				JOptionPane.showMessageDialog(this, Name1 + " wins the game!");
				turn.setText(Name1 + " wins!");
				setVisible(false);
			
			case 2: // game is tied
				JOptionPane.showMessageDialog(this, " The game is tied. ");
				turn.setText("Game is tied!");
				setVisible(false);
				
			}

			disableAllplayoffs(true);
			return true; // end of the end of the game
		}
		if (mainInterfaceFull()) // its  boolean method
		{
			disableAllplayoffs(true);
			turn.setText("Game tied!");
			setVisible(false);
		}
		return false;// end
	}

	